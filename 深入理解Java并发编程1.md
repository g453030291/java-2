#### 一、什么是线程安全？什么是进程？什么是线程？

wiki中的解释是：

	线程安全是编程中的术语，指某个函数、函数库在并发环境中被调用时，能够正确处理多个线程之间的共享变量，使程序功能正确完成。

需要正确理解三个概念，1.并发、2.多线程、3.共享变量。

	并发（Concurrent）：在操作系统中，指一个时间段中有好几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行。
	
	并行（Parallel）：当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，这种方式称为并行。
	
	进程和线程：对于操作系统来说，一个任务就是一个进程。一个进程内部，需要同时做多件事，就需要同时运行多个子任务，这些子任务称为线程。进程作为资源分配的基本单元，线程当作执行的基本单元，同一个进程的多个线程之间共享资源。
	
	共享变量：指多个线程都可以操作的变量。
	
	对于JVM来说，保存在堆和方法区的变量就是Java中的共享变量。Java中共有三种变量，类变量、成员变量、局部变量。他们分别存储在JVM的方法区、堆、栈中。

```java
public class Variables{
    //类变量
    private static int a;
    //成员变量
    private int b;
    //局部变量
    public  void test(int c){
        int d;
    }
}
```

	以上定义的三个变量中，a是类变量，b是成员变量，c和d是局部变量。多线程环境中，变量a、b是需要考虑线程安全问题的。

#### 二、并发编程中最重要的三个特征是什么？

原子性、可见性、有序性。

#### 三、并发编程中的原子性是什么？数据库的ACID的A也是原子性，这两个原子性有什么区别？

原子性是指：一个操作时不可中断的，要么全部执行，要不就都不执行。

数据库事务中，保证原子性通过事务的提交和回滚，但在并发编程中，是不涉及回滚的。所以，并发编程中的原子性，强调的是一个操作的不可分割性。

所以在并发编程中，原子性的定义不应该和事务中的原子性完全一样。他应该定义为：一段代码，或者一个变量的操作，在没有执行完之前，不能被其他线程执行。

#### 四、并发编程中的有序性是什么？如果不能保证有序性会发生什么问题？

有序性即程序执行的顺序按照代码的先后顺序执行。

Java程序中天然的有序性可以总结为：如果在本线程内观察，所有操作都是天然有序的。如果在一个线程中观察另一个线程，所有操作都是无序的。

比如i+1，可以分解为

Load i;

add 1;

Save 1;

如果这三个指令的顺序被重排，那么结果可能截然不同了。一旦不满足有序性，那么执行结果就会和预期不同。

多线程场景中，有序性需要保证多个线程执行操作，和单线程顺序执行多次结果一致。

#### 五、什么情况下会影响程序执行的顺序？（为什么有序性会被破坏）

现代编译器会对代码指令重排序，在重排的情况下，代码的执行顺序就有可能会被改变。

#### 六、什么是并发程序中的可见性？

可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

#### 七、并发编程中，如果无法保证可见性，会出现什么问题？

如果无法保证可见性，那么就是说多个线程之间的本地内存中对于同一变量的值是不同的。

线程1从主内存中取出a=1，保存到自己的工作内存。

线程1在自己的内存中取出a=1，进行a=a+1。

线程2从主存中取出a=1。

以上情况，线程1对于变量a的修改就不具有可见性。

#### 八、什么是线程优先级？线程优先级有什么用？

虽然Java线程调度是系统自动完成的，但是我们还是可以"建议"系统给某些线程多分配一点执行时间，另一些线程可以少分配一点。这项操作可以通过设置线程优先级来完成。Java语言一共设置了10个级别的线程优先级（Thread.MIN_PRIORITY至Thread.MAX_PRIORITY），在两个线程同时处于Ready状态时，优先级越高的线程越容易被系统选择执行。

#### 九、什么是守护线程？如何创建守护线程？

在java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程)。用户线程一般用户执行用户级任务，而守护线程也就是"后台线程"，一般用来执行后台任务，守护线程最典型的应用就是GC。

这两种线程其实是没有什么区别的，唯一区别就是Java虚拟机在所有"用户线程"都结束后就会退出。

我们可以通过setDaemon()方法通过传递true为参数，使线程成为一个守护线程。我们必须在启动线程之前调用一个线程的setDaemon()方法。否则，就会抛出java.lang.IllegalThreadStateException。

可以使用isDaemon（）方法来检查线程是否是守护线程。

注意：在Daemon线程中产生的新线程也是Daemon的。

#### 十、什么是ThreadLocal，和线程有什么关系？

ThreadLocal是java.lang下面的一个类，是用来解决java多线程程序中并发问题的一种途径。通过为每一个线程创建一份共享变量的副本来保证各个线程之间的变量的访问和修改互相不影响。

ThreadLocal存放的值是线程内共享的，线程间互斥的，主要用于线程内共享一些数据，避免通过参数来传递，这样处理后，能够优雅的解决一些实际问题。

比如一次用户的页面请求操作，我们可以在最开始的filter中，把用户信息保存在ThreadLocal中，再同一次请求中，再使用到用户信息，就可以直接到ThreadLocal中获取就可以了。

还有一个典型的应用就是保存数据库连接，我们可以在第一次初始化Connection的时候，把它保存在ThreadLocal中。

ThreadLocal有四个方法：

initialValue：返回此线程局部变量的初始值

get：返回此线程局部变量的当前线程副本中的值。如果这是线程第一次调用该方法，则创建并初始化此副本。

set：将此线程局部变量的当前线程副本中的值设置为指定值。许多应用程序不需要这项功能，他们只依赖于initialValue（）方法来设置线程局部变量的值。

remove：移除此线程局部变量的值。

#### 十一、什么是线程池？

线程池是池化技术的一种典型实现，所谓池化技术就是提前保存大量的资源，以备不时之需。在机器资源有限的情况下，使用池化技术可以大大提高资源的利用率，提升性能。

#### 十二、为什么不建议使用Executors创建线程池？

Executors底层是通过LinkedBlockingQueue实现的。

LinkedBlockingQueue是一个用链表实现的有界阻塞队列，容量可以选择进行设置，不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE。

而Executor创建线程池时，并未指定容量。此时，LinkedBlockingQueue就是一个无边界队列，对于一个无边界队列来说，可以不断的向队列中加入任务的，这种情况下就可能因为任务过多而导致内存溢出问题。

#### 十三、Java中如何使用线程池？

推荐使用guava提供的ThreadFactoryBuilder来创建线程池。

```java
public class ExecutorsDemo{
  private static ThreadFactory NamedThreadFactory = new ThreadFactoryBuilder().setNameFormat("demo-pool-%d").build();
  
  private static ExecutorService pool = new ThreadPoolExecutor(5,200,0L,TimeUnit.MILLISECONDS,new LinkedBlockingQueue<Runnable>(1024),namedThreadFactory,new ThreadPoolExecutor.AbrtPolicy());
  
  public static void main(String[] args){
    for(int i=0;i<Integer.MAX_VALUE;i++){
      pool.execute(new SubThread());
    }
 }
}
```

#### 十四、Executors类可以创建多少种线程池，各有什么特点？

Executors的创建线程池的方法，创建出来的线程池都实现了ExecutorService接口。常用方法有以下几个：

newFiexedThreadPool(int Threads)：创建固定数目的线程池。

newCachedThreadPool()：创建一个可缓存的线程池，调用execute将重用以前构造的线程（如果线程可用）。如果没有可用的线程，则创建一个新线程。终止并从缓存中移除那些已有60秒钟未被使用的线程。

newSingleThreadExecutor()：创建一个单线程化的Executor。

newScheduledThreadPool(itn corePoolSize)：创建一个支持定时及周期性的任务执行的线程池，多数情况下可以用来替代Timer类。

#### 十五、Java中如何创建线程？

在Java中，共有四种方式可以创建线程，分别是继承Thread类创建线程、实现Runnable接口创建线程、通过Callable和FutureTask创建线程以及通过线程池创建线程。


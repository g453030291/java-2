#### 平均负载多少合理？

查看本机有多少个CPU

`grep 'model name' /proc/cpuinfo | wc -l`

当平均负载的数值大于CPU个数的时候，说明系统出现了过载。当平均负载超过CPU个数的70%的时候，就需要排查问题。

#### 平均负载与CPU使用率

平均负载与CPU使用率并不完全相等：

CPU密集型进程，使用大量CPU会导致平均负载升高，此时两者是一致的

I/O密集型进程，等待I/O也会导致平均负载升高，但CPU使用率不一定很高

大量等待CPU的进程调度也会导致平均负载升高，此时的CPU使用率也会比较高

#### Linux性能监控工具sysstat

安装sysstat后，两个常用的命令：

	mpstat是一个常用的多核CPU性能分析工具，用来实时查看每个CPU的性能指标，以及所有CPU的平均指标。

	pidstat是一个常用的进程性能分析工具，用来实时查看进程的CPU、内存、I/O以及上下文切换等性能指标。

`mpstat -P ALL 5`：表示监控所有CPU，5秒间隔输出CPU运行情况

`pidstat -u 5 1`：每间隔5秒输出一组进程占用资源情况数据

#### 如何查看Linux系统上下文切换情况

vmstat工具，常用来分析系统内存使用情况，和CPU上下文切换和中断的次数

`vmstat 5`：间隔5秒输出一组数据

cs（context switgh）：是每秒上下文切换的次数

in（interrupt）：每秒中断的次数

r（Running or Runnable）：就绪队列的长度，也就是正在运行和等待CPU的进程数

b（Blocked）：处于不可中断睡眠状态的进程数

使用上面用过的pidstat查看每个进程的详细情况：`pidstat -w 5`

cswch：表示每秒自愿上下文切换的次数

nvcswch：表示每秒非自愿上下文切换的次数

	<u>这两个参数非常重要。自愿上下文切换，表示进程无法获取所需资源，导致的上下文切换。比如，I/O、内存等系统资源不足时，就会发生自愿上下文切换。而，非自愿上下文切换，则是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换。比如大量进程都在争抢CPU时，就容易发生非自愿上下文切换。</u>

`pidstat -wt 1`：每隔一秒输出，-wt表示输出线程上下文切换指标

`watch -d cat /proc/interrupts`：观察输出，会发现，变化速度最快的是重调度中断（RES），这个中断类型表示，唤醒空闲状态的CPU来调度新的任务运行。这是多处理器系统（SMP）中，调度器用来分散任务到不同CPU的机制，通常也被称为处理器间中断。

#### CPU每秒上下文切换多少次才是正常？

	这个数值取决于系统本身CPU的性能。如果系统上下文切换次数比较稳定，那么从数百到一万以内，都算正常。但是上下文切换次数超过一万，或者切换次数出现数量级增长，就很可能出现了性能问题。

	这个时候，还需要根据具体上下文切换的类型， 再做具体分析。如：

* 自愿上下文切换变多了，说明进程都在等待资源，可能发生了I/O等问题
* 非自愿上下文切换变多了，说明进程都在被强制调度，也就是都在争抢CPU，说明CPU成为了瓶颈
* 中断次数变多了，说明CPU被中断程序占用，这时需要查看/proc/interrupts文件来分析具体中断类型

#### 如何查看CPU使用率？

top命令，默认显示的所有CPU的平均值，按下1，会切换出每个CPU的使用率：

参数释义：

* us（user）：代表用户态CPU时间，注意，它不包括下面的nice时间，但包括了guest时间

* ni（nice）：代表低优先级用户态CPU时间，也就是进程的nice值被调整为1-19之间时的CPU时间。这里注意，nice可取值范围是-20到19，数值越大，优先级反而越低

* sys（system）：代表内核态CPU时间

* id（idle）：代表空闲时间，注意，它不包括等待I/O的时间

* wa（iowait）：代表等待I/O的CPU时间

* hi（irq）：代表处理硬中断的CPU时间

* si（softirq）：代表处理软中断的CPU时间

* st（steal）：代表当系统运行在虚拟机中的时候，被其他虚拟机占用的CPU时间

* guest（guest）：代表通过虚拟化运行其他操作系统的时间，也就是运行虚拟机的CPU时间

* gnice（guest_nice）：代表以低优先级运行虚拟机的时间



  但是top命令并没有严格区分用户态CPU和内核态CPU。可以使用pidstat来查看：

  `pidstat 1 5`：每隔1秒输出，共输出5组

  * %usr：用户态CPU使用率

  * %system：内核态CPU使用率
  * %guest：运行虚拟机CPU使用率
  * %wait：等待CPU使用率
  * %CPU：总的CPU使用率

#### CPU使用率过高怎么办？

perf是内置的性能分析工具。

`perf top -g -p <pid>`：类似于top，能够显示占用CPU时钟最多的函数或者指令

* Overhead：是该符号的性能事件在所有采样中的比例，用百分比表示
* Shared：是该函数或指令所在的动态共享对象，如内核、进程名、动态链接库名、内核模块名
* Object：是动态共享对象的类型。比如[.]表示用户空间的可执行程序，而[k]表示内核空间
* Symbol：是符号名，也就是函数名。当函数未知时，用十六进制的地址表示

`perf record`、`perf report`：perf top无法保存数据，需要使用perf record保存数据（输入后，按ctrl+c终止采样），保存后的数据使用perf report查看。（实际使用中，通常会加上-g参数，开启调用关系的采样，方便根据调用链来分析性能问题）

	CPU使用率是最直观和最常用的系统性能指标。要弄清楚用户（%user）、Nice（%nice）、系统（%system）、等待I/O（%iowait）、中断（%irq）以及软中断（%softirq）这几种不同的CPU使用率。比如：

* 用户CPU和Nice CPU高，说明用户态进程占用了较多的CPU，所以应该着重排查进程的性能问题
* 系统CPU高，说明内核态占用了较多了CPU，所以应该着重排查内核线程或者系统调用的性能问题
* I/O等待CPU高，说明等待I/O的时间比较长，所以应该着重排查系统存储是不是出现了I/O问题
* 软中断和硬中断高，说明软中断或硬中断的处理程序占用了较多的CPU，所以应该着重排查内核中的中断服务程序

#### top命令下的S列的含义

S（Status），表示进程的状态：

* R：是Running的缩写，表示进程在CPU的就绪队列中，正在运行或正在等待运行
* D：是Disk Sleep的缩写，也就是不可中断睡眠状态，一般表示进程正在跟硬件交互，交互过程不允许被打断
* Z：是Zombie的缩写，表示僵尸进程，也就是进程实际上已经结束了，但是父进程还没有回收它的资源
* S：是Interruptible Sleep的缩写，也就是可中断状态睡眠，表示进程因为等待某个事件而被系统挂起。当进程等待的事件发生时，它会被唤醒进入R状态
* I：是Idle的缩写，也就是空闲状态，用在不可中断睡眠的内核线程上。前面硬件交互导致的不可中断进程用D表示，但对某些内核线程来说，实际上可能没有任何负载。Idle正是为了区分这种情况
* T：是stopped的缩写，表示暂停状态或跟踪状态
* X：是dead的缩写，表示进程已经消亡

#### 如何处理iowait升高

`dstat 1 10`：这里会发现，磁盘读请求很大

使用top命令，找出可疑的D状态的进程

`pidstat -d -p <pid> 1 3`：-d展示I/O统计数据，-p指定进程号，间隔1秒输出3组数据

`pidstat -d 1 20`：直接执行，查看所有进程的磁盘读写情况

`ps aux | grep <pid>`：查看某个进程的状态

`perf record -g`、`perf report`：记录调用情况，打开查看调用栈 

#### 如何处理系统中的僵尸进程

`pstree -aps <pid>`：-a表示输出命令行选项，p表示pid，s表示指定进程的父进程

#### 如何理解Linux系统中的软中断？

中断是一种异步的时间处理机制，用来提高系统的并发处理能力。中断事件发生，会触发执行中断处理程序，而中断处理程序被分为上半部和下半部这两个部分。

上半部对应硬中断，用来快速处理中断；

下半部对应软中断，用来异步处理上半部未完成的工作。

Linux中的软中断包括网络收发、定时、调度、RCU锁等各种类型，我们可以查看proc文件系统中的/proc/softirqs，观察软中断的运行情况。

在Linux中，每个CPU都对应一个软中断内核线程，名字是ksoftirqd/CPU编号。当软中断事件的频率过高时，内核线程也会因为CPU使用率过高而导致软中断处理不及时，进而引发网络收发延迟、调度缓慢等性能问题。

#### 如何解决由于软中断导致CPU使用率过高的问题？

三个工具：

sar：是一个系统活动报告工具，既可以实时查看系统的当前活动，又可以配置保存和报告历史统计数据。

hping3：是一个可以构造TCP/IP协议数据包的工具，可以对系统进行安全审计、防火墙测试等

tcpdump：是一个常用的网络抓包工具，常用来分析各种网络问题

查看/proc/softirqs文件内容：

`watch -d cat /proc/softirqs`：TIMER（定时中断）、NET_RX（网络接收）、SCHED（内核调度）、RCU（RCU锁）等几个软中断都在不断变化

可以看出，NET_RX变化最快，那么就可以从网络接收的软中断着手。

使用sar，查看网络收发情况。

`sar -n DEV 1`：-n DEV表示显示网络收发情况的报告，间隔1秒输出一组数据

这里发现，eth0网卡的网络波动比较大。可以使用tcpdump工具，来指定抓取eth0上的包。

`tcpdump -i eth0 -n tcp port 80`：-i eht0只抓取eth0网卡，-n不解析协议名和主机名

之类可以找到：Flags[S]这样的输出，表示这是一个SYN包。加上前面sar发现的，PPS超过12000，可以确认，这是对应ip发过来的SYN FLOOD攻击。

SYN FLOOD攻击，最简单的解决办法，就是从交换机或者硬件防火墙中封掉来源ip。

#### CPU性能指标有哪些？

1.CPU使用率

* 用户CPU使用率：包括用户态CPU使用率（user）和低优先级用户态CPU使用率（nice），表示CPU在用户态运行的时间百分比。用户CPU使用率高，通常说明有应用程序比较繁忙
* 系统CPu使用率：表示CPU在内核态运行的时间百分比（不包括中断）。系统CPU使用率高，说明内核比较繁忙
* 等待I/O的CPU使用率：通常称为iowait，表示等待I/O的时间百分比。iowait高，说明系统与硬件设备的I/O交互时间比较长
* 软中断和硬中断的CPU使用率：分别表示内核调用软中断处理程序、硬中断处理程序的时间百分比。它的使用率高，说明系统发生了大量中断
* 除了上面这些，还有在虚拟化环境中用到的窃取CPU使用率（steal）和客户CPU使用率（guest），分别表示被其他虚拟机占用的CPU时间百分比，和运行客户虚拟机的CPU时间百分比

2.平均负载

`uptime`：分别指过去1分钟，5分钟，15分钟的平均负载。

理想情况下，平均负载等于逻辑CPU个数，这表示每隔CPU都恰好被充分利用。如果平均负载大于CPU个数，表示负载比较重。

3.进程上下文切换

包括：无法获取资源导致的自愿上下文切换、被系统强制调度导致的非自愿上下文切换。

4.CPU缓存命中率

#### 如何分析系统CPU瓶颈？

根据指标找工具（CPU性能）

| 性能指标          | 工具                                 | 说明                                                         |
| ----------------- | ------------------------------------ | ------------------------------------------------------------ |
| 平均负载          | uptime、top                          | uptime最简单；top提供全面的指标；                            |
| 系统整体CPU使用率 | vmstat、mpstat、top、sar、/proc/stat | top、vmstat、mpstat只可以动态查看，而sar还可以记录历史数据；/proc/stat是其他性能工具数据来源 |
| 进程CPU使用率     | top、pidstat、ps、htop、atop         | top和ps可以按CPU使用率给进程排序，而pidstat只显示实际用了CPU的进程；htop和atop以不同颜色显示更直观 |
| 系统上下文切换    | vmstat                               | 除了上下文切换次数，还提供运行状态和不可中断状态进程的数量   |
| 进程上下文切换    | pidstat                              | 注意加上-w选项                                               |
| 软中断            | top、/proc/softirqs、mpstat          | top提供软中断CPU使用率；而/proc/softirqs和mpstat提供了各种软中断在每个CPU上的运行次数 |
| 硬中断            | vmstat、/proc/interrupts             | vmstat提供总的中断次数，而/proc/interrupts提供各种中断在每个CPU上运行的累积次数 |
| 网络              | dstat、sar、tcpdump                  | dstat和sar提供总的网络接收和发送情况，而tcpdump则是动态抓取正在进行的网络通信 |
| I/O               | dstat、sar                           | dstat和sar都提供了I/O整体情况                                |
| CPU个数           | /proc/cpuinfo、Iscpu                 | Iscpu更直观                                                  |
| 事件剖析          | perf、execsnoop                      | perf可以用来分析CPU的缓存以及内核调用链，execsnoop用来监控短时进程 |

根据工具查指标（CPU性能）

| 性能工具         | CPU性能指标                                                  |
| ---------------- | ------------------------------------------------------------ |
| uptime           | 平均负载                                                     |
| top              | 平均负载、运行队列、整体的CPU使用率以及每个进程的状态和CPU使用率 |
| htop             | top增强版，以不同颜色区分不同类型进程                        |
| atop             | CPU、内存、磁盘和网络等各种资源全面监控                      |
| vmstat           | 系统整体的CPU使用率、上下文切换次数、中断次数，还包括处于运行和不可中断状态的进程数量 |
| mpstat           | 每个CPU的使用率和软中断次数                                  |
| pidstat          | 进程和线程的CPU使用率、中断上下文切换次数                    |
| /proc/softirqs   | 软中断类型和在每个CPU上累计中断次数                          |
| /proc/interrupts | 硬中断类型和在每个CPU上的积累中断次数                        |
| ps               | 每个进程的状态和CPU使用率                                    |
| pstree           | 进程的父子关系                                               |
| dstat            | 系统整体的CPU使用率                                          |
| sar              | 系统整体的CPU使用率，包括可配置的历史数据                    |
| strace           | 进程的系统调用                                               |
| perf             | CPU性能事件剖析，如调用链分析、CPU缓存、CPU调度等            |
| execsnoop        | 监控短时进程                                                 |

如何快速分析系统的CPU瓶颈？

可优先使用top、vmstat和pidstat这三个工具。

![cpu瓶颈分析.PNG](https://github.com/g453030291/java-2/blob/master/images/cpu瓶颈分析.PNG)

可以借助上面的图，从最核心的几个工具开始，分析cpu瓶颈。

#### 怎样查看系统内存使用情况？

`free`：显示整个系统的内存使用情况

* total：总内存大小
* used：已使用内存大小
* free：未使用内存大小
* shared：共享内存大小
* buff/cache：缓存和缓冲区大小
* available：新进程可用内存大小

`top` + M：查看进程的内存使用情况

VIRT：进程虚拟内存大小，只要是进程申请过的内存，即便还没有真正分配物理内存，也会计算在内

RES：常驻内存大小，也就是进程实际使用的物理内存大小，但不包括Swap和共享内存

SHR：共享内存的大小，比如与其他进程使用的共享内存、加载的动态链接库以及程序代码段

%MEM：进程使用物理内存占系统总内存的百分比

#### Linux中的Buffer和Cache有什么区别？

Buffer：从磁盘读写数据时，做缓存

Cache：从文件读写数据时，做页缓存

#### 如何观察系统中的缓存命中率？

cachestat：提供了整个系统缓存的读写命中情况

cachetop：提供了每个进程的缓存命中情况

#### 如何处理内存泄漏？

1.使用vmstat工具查看内存情况：`vmstat 3`；这里观察到free逐渐缩小，但buff和cache并没有很大的变化，有内存泄漏的可能

2.使用bcc软件包（需要手动安装，并且升级Linux内核）中的memleak工具。

3.`/usr/share/bcc/tools/memleak -a -p $(pidof app)`

4.观察输出结果，找出没有释放内存的函数
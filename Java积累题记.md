#### 一、什么是面向对象，什么是面向过程。面向对象的三大基本特征和五大基本原则是什么？

面向过程：把问题分解成一个一个步骤，每个步骤用函数实现，依次调用即可。就是说，面向过程编程的时候，直接定义一个函数，然后使用各种诸如if-else、for-each等方式进行编码执行。

面向对象：将问题分解成一个一个步骤，进行相应的抽象，形成对象，通过不同对象之间的调用，组合解决问题。就是说，在进行面向对象编程的时候，要把属性、行为等封装成对象，然后基于这些对象及对象的能力进行业务逻辑的实现。比如想造一辆汽车，先要把车的各种属性定义出来，然后抽象成一个car类。

面向对象的三大特征和五大基本原则？

三大特征：封装、继承、多态

五大基本原则：单一职责原则、开放封闭原则、里氏替换原则、依赖倒置原则、接口隔离原则

#### 二、什么是值传递？什么是引用传递？为什么说Java中只有值传递？

首先要理解值传递、引用传递的概念。

值传递：指在调用函数时，将实际参数<u>复制</u>一份传递到函数中，这样在函数中如果对<u>参数</u>进行修改，将不会影响到实际参数。

引用传递：指在调用函数时，将实际参数的<u>地址</u>直接传递到函数中，那么在函数中对<u>参数</u>所进行的修改，将影响到实际参数。

重点：

|          | 值传递                 | 引用传递               |
| -------- | ---------------------- | ---------------------- |
| 根本区别 | 会创建副本             | 不创建副本             |
| 所以     | 函数中无法改变原始对象 | 函数中可以改变原始对象 |

举例：

```java
public static void main(String[] args){
    ParamTest pt = new ParamTest();
    
    User u = new User();
    u.setName("aaa");
    u.setGender("bbb");
    pt.pass(u);
    System.out.println("print in main , user is " + u);
}

public void pass(User user){
    user = new User();
    user.setName("change aaa");
    user.setGender("change bbb");
    System.out.println("print in pass , user is "+ user);
}
```

输出：

```java
print in pass , user is User{name='change aaa', gender='change bbb'}
print in main , user is User{name='aaa', gender='bbb'}
```

理解：

	这里User u = new User();在堆中给u分配了一个内存地址，存储着aaa，bbb。在pass方法中的形参user接收到的，其实是u的内存地址。也就是说，此时，u和pass的形参user指向的是堆中同一个地址。如果下面没有new User();的操作，那么对user的操作，会直接操作堆中u的对象。这么看来，Java中不是应该是引用传递吗？为什么说是Java中只有值传递呢？其实，这里传递的值是对象的引用地址。而对于普遍认识的基本数据类型，都是传递的副本。所以：<u>1.值传递和引用传递的区别并不是传递的内容，而是实参到底有没有被复制一份给形参。2.Java中其实只存在值传递，只不过对于对象参数，值的内容是对象的引用。</u>

总结：

	无论是值传递还是引用传递，其实都是一种求值策略。在求值策略中，其实还有一种按共享传递。<u>Java的参数传递严格上是按共享传递。</u>
	
	简单说，Java中的传递，是值传递，而这个值，实际上是对象的引用。

按共享传递：

	指在调用函数时，传递给函数的是实参的地址的拷贝（如果实参在栈中，则直接拷贝该值），在函数内部对参数进行操作时，需要先到拷贝的地址寻找到具体的值，再进行操作。如果该值在栈中，那么因为是直接拷贝值，所以函数内部对参数进行操作，不会对外部变量，产生影响。如果原来拷贝的是原值在堆中的地址，那么需要先根据该地址找到堆中对应的位置，再进行操作。因为传递的是地址的拷贝所以函数内对值的操作对外部变量是可见的。<u>共享传递只是按值传递的一个特例。</u>

#### 三、什么是Java的语法糖？列举你知道的语法糖，如何解语法糖？

语法糖：在计算机语言中添加某种语法，这种语法对语言功能没有影响，但是更方便程序员使用。简而言之，语法糖让程序更加简洁，有更高的可读性。

解语法糖：语法糖主要方便开发人员使用，但其实JVM并不支持这些语法糖，这些语法糖会在编译阶段还原成简单的基础语法结构，这个就是解语法糖。

Java中的语法糖：

1.swich支持String与枚举：字符串的switch是通过equals()和hashCode()来实现的。进行switch的实际是哈希值，然后通过equals方法比较进行安全检查，为了避免哈希碰撞。

2.泛型：对于JVM来说，它并不认识Map<String,String> map这样的语法，需要在编译阶段通过类型擦除的方式，进行解语法糖。

类型擦除的主要过程如下：

将所有的泛型参数用其最左边界(最顶级的父类型)类型替换。移除所有类型参数。

Map<String,String> map = new HashMap<String,String>();

map.put("name","aaa");

解语法糖会变成：

Map map = new HashMap();

map.put("name","aaa");

JVM中没有泛型，只有普通类和普通方法，所有泛型类的类型参数在编译时都会被擦除，泛型类并没有自己独有的Class类对象。比如，不存在List<String>.class或者List<Integer>.class，只存在List.class。

3.自动装箱与拆箱：比如int和Integer，在装箱的过程中是调用包装器的valueOf(int)，方法实现的，而拆箱过程是通过调用包装器的xxxValue()方法实现。

4.方法变长参数：可变参数是在Java1.5中引入的一个新特性，它允许一个方法把任意数量的值作为参数。（String... str）。反编译后其实这就是传入一个数组，数组的长度就是参数的数量。

5.枚举类型：关键字enum可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用。反编译enum的源码，其实就是public final class T extends Enum。当我们创建一个枚举类型的时候，编译器会自动帮我们创建一个final类型的类即成Enum类。

6.内部类：内部类又称为嵌套类，可以把它理解为一个外部类的普通成员。内部类之所以也是一个语法糖，因为他仅仅是一个编译时的概念，outer.java里定义了一个内部类inner，一旦编译成功，就会生成两个完全不同的.class文件，分别是outer.class和outer$inner.class。所以内部类的类名可以和外部类完全相同。

7.条件编译：有时出于程序代码优化的考虑，希望只对其中一部分代码进行编译，此时就需要在程序中加上条件。让编译器只对满足条件的代码编译。（其实就是使用if条件判断实现的，但在Java语言设计之初，就没有引入条件编译的功能，所以在Java中，条件编译很是鸡肋）。

8.断言：assert关键字

9.数值字面量：整数，或者浮点数都允许在数字间加入一个或多个下划线(_)，这些下划线，只是为了方便阅读，不对数值产生任何影响。

10.for-each：其实就是使用了普通的for循环和迭代器

11.try-with-resource：

```java
public static void main(String... args){
    try(BufferedReader br = new BufferedReader(new FileReader("d:\\aaa.xml"))){
        String line;
        While((line = br.readLine())!=null){
            System.out.println(line);
        }
    }catch(IOException e){
        //handle exception
    }
}
```

是不是比在finally中关闭流优雅了许多？其实，反编译后，关闭流的操作都由编译器替你做了。

#### 四、Lambda表达式是不是语法糖，是如何实现的？

Lambda是语法糖，实现方式是依赖了几个JVM底层的Lambda相关api

```java
public static void main(String... args){
    List<String> list = ImmutableList.Of("aaa","bbb","ccc");
    list.forEach(s->{System.out.println(s);});
}
```

为什么Lambda不是内部类的语法糖 ？因为上面说过，内部类编译后会有两个class文件，但是Lambda编译后只有一个文件，反编译后可以看到，其实内部是调用java.lang.LambdaMetafactory#metafactory方法，该方法中implMethod指定了方法的实现。所以，Lambda表达式的实现是依赖了底层一些api，在编译阶段，编译器会把Lambda表达式进行解糖，转换成调用内部api的方式。

#### 五、什么是方法的重写、重载，成员变量可以背重写吗？

重载（OverLoading）:方法具有同样的方法名，但是参数列表不同。

重写（OverRiding）：子类中有与父类同样方法名、参数的方法。这种情况下，子类的方法将覆盖父类原有的方法。

重点：

1.重载是一个编译期概念，重写是一个运行期概念

2.重载遵循所谓“编译期绑定”，即在编译时根据参数变量的类型判断应该调用哪个方法

3.重写遵循所谓‘运行期绑定“，即在运行时，根据引用变量所指向的实际对象的类型来调用方法

4.因为在编译期已经确定了调用哪个方法，所以重载并不是多态。重写是多态。重载只是一种语言特性，是一种语法规则，与多态、面向对象无关。（严格来说：重载是编译期多态，即静态多态，但Java中提到的多态，默认都指动态多态）

隐藏：

	在一个类中，子类中的成员变量如果和父类中的成员变量同名，那么即使他们类型不一样，只要名字一样，父类中的成员变量都会被隐藏。子类中，父类的成员变量不能被简单的用引用来访问。而是必须从父类的引用获得父类被隐藏的成员变量。（一般不推荐这样使用，因为会降低代码的可阅读性）。

	简单来说就是，子类不会重写覆盖父类的成员变量，所以成员变量的访问不能像方法一样使用多态去访问。

#### 六、接口和抽象类的区别？

接口中只是定义了一些方法，不考虑Java8的default方法的情况下，接口中是没有代码实现的。接口中只有public修饰符，无法修改。

抽象类中的抽象方法可以有public、protected、default这些修饰符。

使用：一般把接口暴漏给外部，然后在业务代码中，实现接口。如果在多个实现类中有可复用的代码，则在接口和实现类中间加一层抽象类，将公共代码抽到抽象类中。（参考模版方法模式）

#### 七、什么是构造函数？什么是默认构造函数？构造方法能不能被重载？能不能被重写？

1.构造函数是一种特殊的方法，主要在创建对象时初始化对象，即为对象的成员变量赋初始值，与new运算符在一起使用，一个类可以有多个构造函数。即构造函数的重载。

	构造函数没有返回值类型，不会被继承，且有范围修饰符。构造期的函数名必须和类名相同。

2.如果在辨析一个可实例化的类时，没有专门编写构造函数，多数编程语言会自动生成缺省构造器（默认构造函数）。默认构造函数会把成员变量值初始化为默认值，int->0，integer->null。

3.构造方法可以被重载，实现对象数据不同的初始化。

4.构造方法不能被重写，子类不能继承父类的构造方法，只能在子类的构造方法中调用父类的构造方法（自动调用父类默认的构造方法，或调用父类指定的构造方法），保证父类对象也进行初始化（子类继承父类对象数据得到初始化）。

#### 八、成员变量和方法的作用域，public、protected、private以及不写之间的区别？

| 作用域、可见性 | 当前类 | 同一package | 子类   | 其他package |
| -------------- | ------ | ----------- | ------ | ----------- |
| public         | 可见   | 可见        | 可见   | 可见        |
| private        | 可见   | 不可见      | 不可见 | 不可见      |
| protected      | 可见   | 可见        | 可见   | 不可见      |
| default        | 可见   | 可见        | 不可见 | 不可见      |

#### 九、接口能否继承接口？抽象类能否实现接口？抽象类能否继承具体类？

接口可以继承

抽象类可以实现接口

抽象类可以继承具体类

#### 十、String类能不能被继承，为什么？这种设计有什么好处？

1.缓存Hashcode：Java中经常需要用到字符串的哈希码(hashcode)，字符串的不可变能保证其hashcode永远保持一致，这样需要使用每一个字符串hashcode时不需要重新计算一次。

2.安全性：string被广泛使用在Java其他类中充当参数，比如网络连接、打开文件等操作。如果字符串可变，那么类似操作就会有安全问题。

3.不可变对象天生就是线程安全的：因为不可变对象不能被改变，所以它们可以自由地在多线程之间共享。不需要同步处理。
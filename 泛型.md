#### 一、什么是Java中的泛型？

Java泛型（generics）是JDK5中引入的一个新特性，允许在定义类和接口的时候使用类型参数（type parameter）。声明的类型参数在使用时用具体的类型来替换。泛型最主要的应用是在JDK5中的新集合类框架中。

泛型最大的好处是可以提高代码的复用性。以List接口为例，我们可以将String、Integral等类型放入List中，如不用泛型，存放String类型要写一个List接口，存放Integer要写另外一个List接口，泛型可以很好的解决这个问题。

#### 二、什么是类型擦除？

类型擦除（type erasue）：类型擦除指的是通过类型参数合并，将泛型类型实例关联到同一份字节码上，编译器只为泛型类型生成一份字节码，并将其实例关联到这份字节码上，类型擦除的关键在于从泛型类型中清除类型参数的相关信息，并且在必要的时候添加类型检查和类型转换的方法。类型擦除可以简单的理解为将泛型java代码转换为普通java代码，只不过编译器更直接点，将泛型java代码直接转换成普通java字节码。类型擦除的主要过程如下：1.将所有的泛型参数用其最左边界（最顶级的父类型）类型替换。2.移除所有的类型参数。

Java编译器处理泛型的过程：

```java
public static void main(String[] args){
    Map<String,String> map = new HashMap<String,String>();
    map.put("name","hollis");
    map.put("age","22");
    System.out.println(map.get("name"));
    System.out.println(map.get("age"));
}
```

反编译后的结果为：

```java
public static void main(String[] args){
    Map map = new HashMap();
    map.put("name","hollis");
    map.put("age","22");
    System.out.println((String)map.get("name"));
    System.out.println((String)map.get("age"));
}
```

可以看出，泛型都不见了，程序又变回了Java泛型出现之前的写法，泛型类型都变成了原生类型。

泛型带来的问题：

1.当泛型遇到重载

```java
public class GenericTypes{
    public static void method(List<String> list){
        System.out.println("invoke method(List<String> list)");
    }
    public static void method(List<Integer> list){
        System.out.println("invoke method(List<Integer> list)");
    }
}
```

上面这段代码，有两个重载的函数，因为他们的参数类型不同，一个是List<String>另一个是List<Integer>，但是，这段代码是编译通不过的。因为我们前面讲过，参数List<Integer>和List<String>编译之后都被擦除了，变成了一样的原生类型List，擦除动作导致这两个方法的特征签名变得一摸一样。

2.当泛型遇到catch

如果我们自定义了一个泛型异常类GenericException,那么，不要尝试用多个catch取匹配不同的异常类型，例如你想要分别捕获GenericException、GenericException，这也是有问题的。

3.当泛型内包含静态变量

```java
public class Static Test{
    public static void main(String[] args){
        GT<Integer> gti = new GT<Integer>();
        gti.var=1;
        GR<String> gts = new GT<String>();
        gts.var=2;
        System.out.println(gti.var);
    }
}
class GT<T>{
    public static int var = 0;
    pulbic void nothing(T x){}
}
```

答案是2，由于经过类型擦除，所有的泛型类实例都关联到同一份字节码上，泛型类的所有静态变量是共享的。

总结：

1.虚拟机中没有泛型，只有普通类和普通方法，所有泛型类的类型参数在编译时都会被擦除，泛型类并没有自己独有的Class对象。比如并不存在List<String>.class或是List<Integer>.class，而只有List.class

2.创建泛型对象时请指明类型，让编译器今早的做参数检查(Effective Java，第23条：请不要在新代码中使用原生态类型)

3.不要忽略编译器的警告信息，那意味着潜在的ClassCastException等着你

4.静态变量是被泛型类的所有实例所共享的对于声明为MyClass<T>的类，访问其中的静态变量的方法仍然是MyClass.myStaticVar。不管是通过new MyClass<String>还是new MyClass<Integer>创建的对象，都是共享一个静态变量

5.泛型类型参数不能用在Java异常处理的catch语句中。因为异常处理是由JVM在运行时刻来进行的。由于类型信息被擦除，JVM是无法区分两个异常类型MyException<String>和MyException<Integer>的。对于JVM来说，他们都是MyException类型的。也就无法执行与异常对应的catch语句。

#### 三、什么是泛型中的限定通配符和非限定通配符？

